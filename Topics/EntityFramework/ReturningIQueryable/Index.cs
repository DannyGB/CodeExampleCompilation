using CodeExampleCompilation.Extensions;
using CodeExampleCompilation.Infrastructure;
using Spectre.Console;

namespace CodeExampleCompilation.Topics.EntityFramework.ReturningIQueryable
{
    public class Index : Page
    {
        public Index() : base("[green]IQueryable[/]")
        {
        }

        public override Markup Content() => @$"When returning data from a database using Entity Framework you must be mindful of where the code that is generated by the EF framework will ultimately be run, will the Linq you have written be run as SQL on the SQL Server or will it be run as C# in your application?

The first [bold yellow]golden rule[/] is to understand which methods will result in the query being materialised (i.e will actually get the data) and which
methods won't. The rule of thumb is that anything like ToList(), First(), FirstOrDefault() etc... will materialise the query so best practice is to return an 
IQueryable from your repository layer and avoid any methods such as those given unless you actually now you want to materialise the query in advance of returning.

Consider the following query:

[bold blue]public IQueryable GetWidgets() => dbContext.Widget.Where(w => w.categoryId == 1).ToList();[/]

This would have the effect of returning all widgets with a category of 1 back to the caller. If the caller then wanted to further select, group, filter etc... all of those operations would be performed in the application rather than at the SQL Server. This may or may not be what is intended but could have a significant memory cost.

For example if the method were called like this:

[bold blue]GetWidgets().Select(w => new {{ w.Id, w.Name }}) => dbContext.Widget.Where(w => w.categoryId == 1);[/]

The Select method would be processed in the application code. That is to say all the columns of the widget table would be returned to the application and then filtered down to just return the Id and name columns

For a better experience you could instead return the query itself to the caller rather than the result of the query (deferred execution), this would then provide them the opportunity to add further processing prior to executing the query at the SQL Server.

For example with the method changed as below:

[bold blue]public IQueryable GetWidgets() => dbContext.Widget.Where(w => w.categoryId == 1);[/]

The caller could use it in the same manner as we saw above:

[bold blue]GetWidgets().Select(w => new {{ w.Id, w.Name }}) => dbContext.Widget.Where(w => w.categoryId == 1);[/]

But this way the Select method would be executed at the SQL server rather than in the application so only the Id and Name columns would ever be returned to the application which could be a significant difference if there are a significant number of rows or columns in the table.

".ToMarkup();
    }
}